---
title: EXPLAIN 사용법
categories: [Study, DB]
tags: [SQL, sql, db, explain, EXPLAIN, query, 실행계획]
description: >-
    EXPLAIN의 사용법을 정리했다.
---

## Explain

많은 양의 데이터를 조회하다보면 조회 속도가 느려지기 마련이다. 이러한 문제를 조금이라도 줄이기 위해서는 쿼리를 튜닝하거나 스키마를 재설계해야 한다. 하지만 스키마를 재설계하게 되면 연계된 테이블과 해당 테이블을 사용하는 쿼리에 영향이 가게 된다. 그래서 보통 쿼리를 튜닝하는데, 이 튜닝을 할 때 사용하는 것이 Explain이다.<br/>
쿼리를 튜닝하기 전에 실행 계획 (explain)을 사용해서 어떤 쿼리가 비효율적인지 확인하는 것이다.

## SQL 수행 절차

1. 사용자가 SQL을 실행한다.
2. DB 엔진의 컴포넌트 중 하나인 파서 (parser)에서 요청된 쿼리를 토큰으로 분리하여 쿼리의 문법이 올바른지 확인한다.
   - 여기서 토큰은 DB가 인식할 수 있는 최소 단위의 어휘를 의미한다.
3. 파서에서 작성된 트리는 전처리기 (preprocessor)로 넘어오게 된다. 전처리기에서는 트리의 구성 요소로 권한과 존재의 여부를 확인한다.
   - 여기서는 쿼리의 구조적 문제를 확인하기 위해 파서에서 넘어온 트리를 분석한다. 쿼리에 사용된 토큰을 내장 함수나 테이블 이름, 컬럼명 등에 매핑해 유효성을 확인하고 쿼리를 실행할 수 있는 권한이 있는지 확인한다.
4. 전처리기에서 검증된 쿼리는 옵티마이저 (optimizer)로 넘어온다.
   - 옵티마이저는 쿼리를 효율적으로 처리하기 위한 실행 계획을 결정하는 컴포넌트다. 종류는 CBO와 RBO 두 가지가 있으며, MySQL의 경우에는 기본적으로 CBO를 사용한다.
     - CBO : Cost Based Optimizer는 디스크 접근 횟수 등 비용을 기준으로 실행 계획을 세우는 방식이다.
     - RBO : Rule Based Optimizer는 미리 정의된 규칙을 기준으로 실행 계획을 세우는 방식이다.
5. 옵티마이저의 실행 계획은 엔진 실행기 (engine executor)로 전달된다. 엔진 실행기는 스토리지 엔진 (Storage Engin)의 데이터 파일에서 데이터를 가져와 사용자에게 최종 결과를 수신한다.

## 사용 방법과 설명

```sql
EXPLAIN [ANALYZE] SELECT (컬럼) FROM (테이블)
```

### 항목별 설명

아래는 explain으로 조회된 결과값의 컬럼별 설명이다.

#### **id**
- id는 실행 계획에서 각 쿼리 단계의 순서를 나타낸다.
- 값이 같으면 같은 단계에서 실행되는 것을 의미하며, 다른 값이면 별도의 쿼리나 서브 쿼리가 실행되는 것이다.
- 값이 1이면 최상위 쿼리이고 숫자가 낮아질수록 서브 쿼리 등의 하위 쿼리에서 실행되는 부분을 의미한다.

#### **select_type**
- 쿼리에서 사용되는 선택자의 유형을 나타내며, 종류는 아래와 같다.

|         구분         | 설명                                                                                                                                                                                                                                                                                                                                                                                                              |
| :------------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|        SIMPLE        | 단순 SELECT문으로, 서브쿼리나 조인, UNION이 없는 쿼리를 말한다.                                                                                                                                                                                                                                                                                                                                                   |
|       PRIMARY        | 서브쿼리나 UNION이 포함된 최상위 SELECT문                                                                                                                                                                                                                                                                                                                                                                         |
|        UNION         | UNION 연산자를 사용한 쿼리문이다. 첫 번째 쿼리는 PRIMARY, 이후 UNION으로 연결된 SELECT문이 UNION으로 표시된다.                                                                                                                                                                                                                                                                                                    |
|   DEPENDENT_UNION    | UNION을 사용할 때 하나의 쿼리가 다른 쿼리에 의존적일 경우 표시된다. 즉, UNION의 일부 쿼리가 외부 쿼리의 결과에 따라 달라지는 경우를 말한다.                                                                                                                                                                                                                                                                       |
|     UNION_RESET      | UNION 결과를 담아두는 임시 테이블로, 실제 쿼리에서 단위 쿼리가 아니기 때문에 별도의 ID값이 부여되지 않는다. (NULL로 표시됨)                                                                                                                                                                                                                                                                                       |
|       SUBQUERY       | 쿼리 내에 서브 쿼리가 있을 때 해당 서브 쿼리를 실행하는 부분으로, 서브쿼리의 결과를 외부 쿼리에서 사용하거나 비교할 때 발생한다.                                                                                                                                                                                                                                                                                  |
|  DEPENDENT_SUBQUERY  | 서브쿼리가 외부 쿼리의 컬럼값에 의존하는 경우로, 서브쿼리의 실행이 외부 쿼리의 각 행에 대해 실행될 때 발생한다.                                                                                                                                                                                                                                                                                                   |
|       DERIVED        | 서브쿼리가 FROM 절에 포함되어 테이블처럼 사용될 때 (==인라인 뷰) 나타난다. 서브쿼리가 파생된 테이블로 취급되면 그 서브쿼리는 DERIVED로 표시된다.                                                                                                                                                                                                                                                                  |
| UNCACHEABLE_SUBQUERY | 서브쿼리가 캐시되지 않는 경우를 말한다. MYSQL은 서브쿼리 결과를 일시적으로 저장해서 재사용할 수 있는데, DEPENDENT_SUBQUERY거나, 비결정 함수 (RAND(), NOW() 등)가 사용되거나, 서브쿼리 내에서 결과를 정렬 (ORDER BY)하거나, 일부만 반환 (LIMIT 등)하거나 서브쿼리가 동적이거나 호출될 때마다 결과가 달라지는 경우에는 캐시할 수 없다. 이때는 서브쿼리를 JOIN으로 변경하거나 인덱스를 활용해 성능을 개선할 수 있다. |
|  UNCACHEABLE_UNION   | UNION 결과가 캐시되지 않는 겨우를 말한다. 이는 UNION에 포함된 쿼리가 외부 쿼리 결과에 의존하거나, ORDER BY, LIMIT 등이 UNION 내에서 사용되었거나 비결정 함수가 사용될 경우 캐시할 수 없다. 이때는 UNION 대신 UNION ALL을 쓰거나, 서브쿼리 최적화, 조인 방식 변경 등으로 성능을 개선할 수 있다.                                                                                                                    |
|     METERIALIZED     | 서브쿼리가 물리적으로 저장되어 실행되는 경우에 나타난다. 서브쿼리가 먼저 계산되고 그 결과가 물리적으로 저장되었다가 사용될 때 발생한다.                                                                                                                                                                                                                                                                           |

#### **table**
- 데이터를 조회하는 테이블 이름을 나타낸다.
- 테이블의 원래 이름이 아닌 축약어가 조회되거나, 서브쿼리일 때는 `<subquery#>`이 출력된다.
  - `<>`로 둘러싸인 이름은 임시 테이블을 의미하며 #은 서브쿼리가 참조하는 단위 select id를 의미한다.
    - 만약 table의 결과값이 `<test2>`라면 id가 2인 단위 쿼리를 수행한 뒤 실행된다는 의미다.

#### **type**
- 옵티마이저가 어떤 방법으로 row를 조회하는지를 나타내는 부분으로, 데이터 접근 방식을 표시한다.
  - all 외의 접근 방식은 모두 인덱스를 사용한다. 만약 all이 반환될 경우에는 해당 쿼리로 사용할 수 있는 적절한 인덱스가 없다는 의미일 수도 있다.

|      구분       | 설명                                                                                                                                                                              |
| :-------------: | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|     system      | 테이블에 단 한 개의 데이터만 있는 경우로, 가장 빠르게 접근 가능하다.                                                                                                              |
|      const      | select에서 기본키나 유니크 키를 사용해 조회하는 경우로, 성능이 가장 좋다. 단, 인덱스를 통한 범위검색은 const가 아니다.                                                            |
|     eq_ref      | 정확히 일치하는 하나의 행을 찾기 위해 인덱스를 사용할 경우 표시된다. 조인 수행 시 가장 유리한 경우다.                                                                             |
|       ref       | 특정 값을 찾기 위해 인덱스를 사용해 범위 검색을 수행할 경우 표시된다.                                                                                                             |
|   ref_or_null   | is null 구문에 대해 인덱스를 활용하도록 최적화된 방식이며 ref와 유사하다. 검색할 null 데이터가 적거나, 해당 방식을 활용할 때 비효율적일 경우 튜닝 대상이다.                       |
|   index_merge   | 두 개의 인덱스를 동시해 사용해서 검색이 이루어질 경우를 말한다.                                                                                                                   |
| unique_subquery | in 서브 쿼리 접근에서 기본 키 또는 고유 키를 사용한 경우를 말한다. 이 방식은 오버헤드를 줄여주기 때문에 속도가 빠르다.                                                            |
| index_subquery  | unique_subquery와 유사하지만 고유 인덱스를 사용하지 않는다는 점이 다르다.                                                                                                         |
|      range      | 특정 범위 내에서 인덱스를 사용해 범위 비교를 할 때 표시된다. 데이터가 방대하지 않다면 단순 조회 시에는 성능이 나쁘지 않다. 다만 스캔 범위가 넓으면 성능 저하의 요인이 될 수 있다. |
|      index      | 인덱스를 풀스캔 해 검색했을 경우를 나타낸다. all보다는 빠르다.                                                                                                                    |
|       all       | 테이블을 풀스캔 해 검색했을 경우를 나타낸다. 검색 데이터가 전체 데이터의 20% 이상일 때는 index보다 성능이 좋을 때도 있다.                                                         |

#### **possible_keys**
  - 옵티마이저가 sql문을 최적화할 때 사용할 수 있는 인덱스 목록이다.

#### **key**
- 옵티마이저가 SQL 최적화를 위해 사용한 기본 키 또는 인덱스명이다.

#### **key_len**
- 인덱스의 길이 (바이트 수)로, 인덱스가 사용하는 열의 크기를 나타낸다. 너무 길면 비효율적일 수 있다.
  - 인덱스가 사용하는 열의 크기를 나타내기 때문에 풀 스캔일 경우 null이 반환된다.

#### **ref**
- reference의 축약어로, 테이블 조인 시 어떤 조건으로 해당 테이블에 액세스 되었는지 알려준다.
- 즉, 키 컬럼에 나와있는 인덱스에서 값을 찾기 위해 선행 테이블의 어떤 컬럼이 사용되었는지를 알려준다.
- 여기서 **const**는 테이블 레코드 건수에 관계없이 쿼리가 기본키나 유니크 키 컬럼을 이용하는 where 조건절을 가지며, 반드시 한 건을 반환하는 쿼리의 처리 방식을 의미한다.

#### **rows**
- 각 단계에서 예상되는 조회된 행 수를 나타낸다. Explain을 단독으로 썼을 경우에는 통계 정보를 바탕으로 한 예측값을 표시하기 때문에 만약 SQL의 최종 결과 건 수 와 row 수가 많이 차이날 경우에는 불필요한 조회가 존재하는 것이기 때문에 튜닝이 필요하다.

#### filtered

- SQL문을 통해 DB 엔진이 스토리지 엔진으로부터 가져온 데이터를 필터 조건에 따라 제거된 비율이다 (%)
- 필터 조건은 where 조건이며, 스토리지 엔진에서 10건을 가져왔고 DB 엔진의 필터 조건을 거쳐 1건이 필터링된다면 filtered 값은 10.00이 된다.
- 다만 통계 값을 바탕으로 계산한 값이기 때문에 반드시 일치하지 않는다.
- 필터가 제대로 동작하지 않을 경우에는 테이블 등을 ANALYZE해서 분석을 해야 한다.

#### **Extra**
- 옵티마이저가 SQL문을 어떻게 해석해 수행할 것인지 추가 정보를 보여주는 항목이다.
- 쿼리 실행 중 추가적인 작업이나 주요 최적화 방법을 설명한다.
  - Using where : where 절의 필터 조건을 사용해 DB 엔진으로 가져온 데이터를 추출하는 경우를 말한다. 테이블에서 행을 가져온 후 추가적인 검색 조건으로 행의 범위를 축소한 것을 표시한다.
  - Using index : 커버링 인덱스로, index only scan이라고도 부른다. 테이블 접근 없이 인덱스만으로 쿼리를 해결했음을 의미한다.

|                 구분                  | 설명                                                                                                                                                                                                           |
| :-----------------------------------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|              Using where              | where절에 필터 조건을 사용해 스토리지 엔진에서 DB 엔진으로 데이터를 추출한 경우로, 테이블에서 행을 가져온 후 추가적인 검색조건으로 행의 범위를 축소한 것을 표시한다.                                           |
|              Using index              | 커버링 인덱스 라고도 하며, index only scan 이라고도 부른다. 테이블 접근 없이 인덱스에만 접근해 쿼리를 해결하는 것을 말한다.                                                                                    |
|               Distinct                | 중복을 제거하는 distinct 키워드나 union 구문이 포함된 경우 표시된다.                                                                                                                                           |
|       Using index for group-by        | using index와 유사하지만 group by가 포함된 쿼리를 커버링 인덱스로 해결할 수 있을 때 표시된다. (인덱스 루스 스캔일 때 노출된다.)                                                                                |
|            Using filesort             | MYSQL의 quick sort인 filesort로 행을 정렬한 것을 나타내며, 정렬이 필요한 데이터를 메모리에 올리고 작업을 수행하겠다는 의미를 가지고 있다. 추가적인 정렬 작업이라서 인덱스를 활용하는지 확인하는 것이 중요하다. |
|            Using temporary            | 암묵적으로 임시 테이블이 생성된 것을 표시한다. 데이터를 가져와 저장한 후 정렬을 수행하거나 중복을 제거하는 작업을 수행할 때 노출되며 임시 테이블이 생기기 때문에 튜닝 대상이 될 수 있다.                       |
|        Using where with pushed        | distinct, group by, order by 구문이 포함된 경우 표시된다.                                                                                                                                                      |
|         Using index condition         | 인덱스 컨디션 pushdown (ICP) 최적화가 일어났음을 표시한다.                                                                                                                                                     |
|               Using MRR               | 멀티 레인지 리드 최적화가 사용되었음을 표시한다.                                                                                                                                                               |
| Using join buffer(Block Nested Loop)  | 조인에 적절한 인덱스가 없어서 중간 데이터 결과를 저장하는 조인 버퍼를 사용하였음을 의미한다.                                                                                                                   |
| Using join buffer(Batched Key Access) | Batched Key Access (BKAJ) 알고리즘을 위한 조인 버퍼를 사용했음을 의미한다.                                                                                                                                     |
|              Not exists               | 하나의 일치하는 행을 찾으면 추가로 행을 더 검색하지 않아도 될 때 출력된다. left join 이나 right join에서 테이블에 존재하지 않는 데이터를 명시적으로 검색할 때 발생한다.                                        |
|              Using union              | 인덱스를 합집합처럼 모두 결합하여 데이터에 접근했음을 의미한다. 보통 or 구문을 썼을 때 표시된다.                                                                                                               |
|            Using intersect            | 인덱스를 교집합처럼 병합해 추출하는 방식이다. 보통 and 구문을 썼을 때 표시된다.                                                                                                                                |
|           Using sort_union            | Using union과 유사하지만 or 구문이 동등 조건이 아닐 때 확인할 수 있다.                                                                                                                                         |
|    no matching row in const table     | 서브쿼리나 조인에서 상수 값과 매칭되는 데이터가 없을 때나 참조 무결성 문제가 존재할 때 발생한다. 즉, 데이터가 없을 때 반환된다.                                                                                |

> ICP는 옵티마이저의 최적화 방식 중 하나로, index condition pushdown 이다. 멀티 컬럼 인덱스에서 왼쪽부터 순서대로 컬럼을 지정하지 않는 경우에도 인덱스를 사용하는 실행 계획인다. 필터 조건을 스토리지 엔진으로 전달하여 필터링 작업에 대한 DB 엔진 부하를 줄이는 방식이다. 이는 스토리지 엔진의 결과를 DB 엔진으로 전송하는 데이터양을 줄여 성능 효율을 높일 수 있다.
{: .prompt-info }

> BKAJ 알고리즘은 
{: .prompt-info }

## 예시

(DDL이랑 쿼리랑 결과값 보여주고 설명 작성)
(기본 쿼리 / join 쿼리 / 서브 쿼리 / group by 등)과 각각의 결과 설명

## EXPLAIN ANALYZE

## OPTIONS

## 후기

## 참고